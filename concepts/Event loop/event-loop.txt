=========================================
ğŸ”¥ JAVASCRIPT EVENT LOOP CHEAT SHEET ğŸ”¥
=========================================

ğŸš€ CORE CONCEPT:
-----------------------------------------
- JavaScript is single-threaded.
- It executes one task at a time (Call Stack).
- Asynchronous tasks (Promises, setTimeout, fetch) are handled by the runtime.
- Event Loop continuously checks:
  1ï¸âƒ£ Is the call stack empty?
  2ï¸âƒ£ If yes â†’ execute all Microtasks
  3ï¸âƒ£ Then â†’ execute one Macrotask
  4ï¸âƒ£ Repeat ğŸ”


âš™ï¸ MAIN COMPONENTS:
-----------------------------------------
1ï¸âƒ£ CALL STACK  â†’ executes synchronous code.
2ï¸âƒ£ WEB APIs    â†’ handle async operations.
3ï¸âƒ£ MICROTASK QUEUE â†’ Promises, async/await continuations.
4ï¸âƒ£ MACROTASK QUEUE â†’ setTimeout, setInterval, I/O, fetch.
5ï¸âƒ£ EVENT LOOP â†’ moves tasks from queues to stack.


ğŸ“¦ PRIORITY ORDER:
-----------------------------------------
1. Synchronous (stack)
2. Microtasks (Promise.then, await)
3. Macrotasks (setTimeout, fetch, DOM events)

ğŸ§  Easy Trick:  Stack â†’ Promise â†’ Timeout


-----------------------------------------
ğŸ§© COMMON OUTPUT PATTERNS
-----------------------------------------

ğŸ§  Example 1:
console.log("A");
setTimeout(() => console.log("B"), 0);
Promise.resolve().then(() => console.log("C"));
console.log("D");

âœ… Output:
A
D
C
B
(Reason: Promise (microtask) before Timeout (macrotask))


ğŸ§  Example 2:
async function foo() {
  console.log("1");
  await Promise.resolve();
  console.log("2");
}
console.log("3");
foo();
console.log("4");

âœ… Output:
3
1
4
2
(Reason: await pauses at microtask, runs after sync)


ğŸ§  Example 3:
setTimeout(() => console.log("A"), 0);
Promise.resolve().then(() => console.log("B"));
console.log("C");

âœ… Output:
C
B
A


ğŸ§  Example 4:
setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => console.log("3"));
}, 0);

Promise.resolve().then(() => {
  console.log("4");
  setTimeout(() => console.log("5"), 0);
});

console.log("1");

âœ… Output:
1
4
2
3
5
(Reason: Promise > Timeout; microtasks inside macrotask run before next macrotask)


ğŸ§  Example 5:
async function test() {
  console.log("D");
  await Promise.resolve();
  console.log("E");
}
console.log("A");
setTimeout(() => {
  console.log("B");
  Promise.resolve().then(() => console.log("C"));
}, 0);
test();
Promise.resolve().then(() => {
  console.log("F");
  setTimeout(() => console.log("G"), 0);
});
console.log("H");

âœ… Output:
A
D
H
E
F
B
C
G


-----------------------------------------
âš¡ MICROTASKS vs MACROTASKS:
-----------------------------------------
MICROTASKS (high priority)
- Promise.then()
- queueMicrotask()
- process.nextTick() (Node.js)
- async/await continuations

MACROTASKS (lower priority)
- setTimeout()
- setInterval()
- setImmediate()
- I/O callbacks
- fetch / network responses

Order Rule:
â†’ After every synchronous task:
   - Run ALL microtasks
   - Then run the next macrotask


-----------------------------------------
ğŸ§© COMMON INTERVIEW Q&A:
-----------------------------------------
Q1. What is the Event Loop?
ğŸ‘‰ Itâ€™s a mechanism that coordinates execution between the Call Stack and Task Queues.

Q2. Why do Promises run before setTimeout?
ğŸ‘‰ Because Promises go in the Microtask Queue, which runs before the Macrotask Queue.

Q3. What does â€œawaitâ€ actually do?
ğŸ‘‰ It pauses async function execution and schedules the rest as a microtask.

Q4. Whatâ€™s the difference between microtask and macrotask?
ğŸ‘‰ Microtasks are processed right after the current stack, before any macrotask.

Q5. Is the Event Loop part of JS Engine?
ğŸ‘‰ âŒ No, itâ€™s part of the runtime (Browser / Node.js).

Q6. What happens if microtasks keep adding new microtasks?
ğŸ‘‰ Infinite microtask loop â†’ macrotasks starved â†’ browser freeze.


-----------------------------------------
ğŸ’¡ QUICK MEMORY RECAP:
-----------------------------------------
ğŸ§  JS is single-threaded
ğŸ§  Stack â†’ Microtasks â†’ Macrotasks
ğŸ§  Promises & await = microtasks
ğŸ§  setTimeout = macrotask
ğŸ§  Microtasks inside macrotask run before next macrotask
ğŸ§  Event Loop = the scheduler that coordinates all this

ğŸ§© Mnemonic:
"**Stack, Promise, Timeout â€” In That Order Always!**"


-----------------------------------------
ğŸ¯ REAL-WORLD APPLICATIONS:
-----------------------------------------
âœ… Avoid UI blocking in browsers.
âœ… Helps async operations run smoothly.
âœ… Critical for understanding Node.js event loop & async behavior.


-----------------------------------------
ğŸ”¥ FINAL REVISION (1-Minute Recap)
-----------------------------------------
â†’ Single Threaded
â†’ Call Stack executes sync
â†’ Web APIs handle async
â†’ Microtasks first (Promise, await)
â†’ Macrotasks later (Timeout)
â†’ Event Loop manages execution flow
â†’ Rule: Synchronous â†’ Microtasks â†’ Macrotasks

=========================================
END OF EVENT LOOP CHEAT SHEET
=========================================
